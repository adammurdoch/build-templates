import freemarker.cache.StringTemplateLoader
import freemarker.template.Configuration

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.freemarker:freemarker:2.3.23'
    }
}

plugins {
    id 'base'
}

class Repo {
    URI uri
}

class BuildModel {
    ProjectModel rootProject = new ProjectModel()
    private Map<String, ProjectModel> subprojects = [:]

    Collection<ProjectModel> getSubprojects() {
        return subprojects.values()
    }

    void addSubproject(ProjectModel project) {
        subprojects[project.name] = project
    }

    ProjectModel getProject(String name) {
        return subprojects[name]
    }
}

class CBuildModel extends BuildModel {
    int sourceCount = 10
    int testCount = 5

    void addLibrary(Map<String, String> args) {
        addSubproject(new CLibraryModel(name: args.name), args.dependsOn)
    }

    void addApp(Map<String, String> args) {
        addSubproject(new CAppModel(name: args.name), args.dependsOn)
    }

    private void addSubproject(CSourceProjectModel project, List<String> dependsOn) {
        project.sourceCount = sourceCount
        project.testCount = testCount
        addSubproject(project)
        for (String dep : dependsOn ?: []) {
            project.dependencies.add(getProject(dep))
        }
    }
}

class ProjectModel {
    String name
}

abstract class CSourceProjectModel extends ProjectModel {
    List<CLibraryModel> dependencies = []
    int sourceCount
    int testCount

    abstract boolean isLibrary()

    String getImplHeaderName() {
        return "${name}_1.h"
    }

    String getImplFunctionName() {
        return "${name}_1"
    }

    List<String> getImplHeaderNames() {
        return (1..sourceCount).collect { "${name}_${it}.h" }
    }

    List<String> getImplSourceNames() {
        return (1..sourceCount).collect { "${name}_${it}.c" }
    }

    List<String> getTestSourceNames() {
        return (1..testCount).collect { "${name}_test_${it}.c" }
    }
}

class CLibraryModel extends CSourceProjectModel {
    @Override
    boolean isLibrary() {
        return true
    }

    String getPublicHeaderName() {
        return "${name}.h"
    }

    String getPublicFunctionName() {
        return implFunctionName
    }
}

class CAppModel extends CSourceProjectModel {
    @Override
    boolean isLibrary() {
        return false
    }
}

abstract class JavaSourceProjectModel extends ProjectModel {
    int sourceCount = 4
    int testCount = 2

    String getBasePackage() {
        return "org.test." + name.toLowerCase()
    }

    abstract boolean isLibrary()

    abstract JavaSourceFileModel getEntryPoint()

    List<JavaSourceFileModel> getProductionClasses() {
        return [entryPoint] + (1..sourceCount-1).collect { n -> new JavaSourceFileModel(project: this, name: "Util$n") }
    }

    List<JavaSourceFileModel> getTestCount() {
        return (1..testCount).collect { n -> new JavaSourceFileModel(project: this, name: "UnitTest$n", referencedClass: entryPoint) }
    }
}

class JavaAppModel extends JavaSourceProjectModel {
    boolean isLibrary() { false }

    @Override
    JavaSourceFileModel getEntryPoint() {
        return new JavaSourceFileModel(project: this, name: "AppMain")
    }
}

class JavaLibraryModel extends JavaSourceProjectModel {
    boolean isLibrary() { true }

    @Override
    JavaSourceFileModel getEntryPoint() {
        return new JavaSourceFileModel(project: this, name: "Lib")
    }
}

class JavaSourceFileModel {
    JavaSourceProjectModel project
    String name
    JavaSourceFileModel referencedClass

    String getPackage() {
        return project.basePackage
    }

    String getQualifiedName() {
        return "${project.basePackage}.${name}"
    }

    String getSourceFileName() {
        return qualifiedName.replace('.', '/') + ".java"
    }
}

class TemplateTask extends DefaultTask {
    @OutputDirectory
    File outputDir

    @TaskAction
    def generate() {
        def configuration = new Configuration(Configuration.VERSION_2_3_23)
        def loader = new StringTemplateLoader()
        configuration.templateLoader = loader
        generate(configuration, loader)
    }

    def generate(Configuration configuration, StringTemplateLoader loader) {
    }

    def generateFile(Configuration configuration, Object root, String templateName, String outputFileName, File outputDir) {
        def template = configuration.getTemplate(templateName)
        def outputFile = new File(outputDir, outputFileName)
        outputFile.parentFile.mkdirs()
        outputFile.withWriter { w -> 
            template.process(root, w)
        }
    }
}

class GradleBuildTask extends TemplateTask {
    @InputFile
    File settingsTemplate

    @InputFile
    File rootProjectTemplate

    @InputFile
    File projectTemplate

    BuildModel build

    @Override
    def generate(Configuration configuration, StringTemplateLoader loader) {
        loader.putTemplate("root-build.gradle", rootProjectTemplate.text)
        loader.putTemplate("project-build.gradle", projectTemplate.text)
        loader.putTemplate("settings.gradle", settingsTemplate.text)
        registerTemplates(loader)
        generateFile(configuration, [build: build], "settings.gradle", "settings.gradle", outputDir)
        generateFile(configuration, [project: build.rootProject], "root-build.gradle", "build.gradle", outputDir)
        build.subprojects.each { p ->
            generateFile(configuration, [project: p], "project-build.gradle", "${p.name}/build.gradle", outputDir)
            generateProjectFiles(configuration, p)
        }
    }

    void registerTemplates(StringTemplateLoader loader) {
    }

    void generateProjectFiles(Configuration configuration, ProjectModel projectModel) {
    }
}

class GradleJvmBuildTask extends GradleBuildTask {
    @InputFile
    File sourceTemplate

    @InputFile
    File testSourceTemplate

    @Override
    void registerTemplates(StringTemplateLoader loader) {
        loader.putTemplate("source.java", sourceTemplate.text)
        loader.putTemplate("test.java", testSourceTemplate.text)
    }

    @Override
    void generateProjectFiles(Configuration configuration, ProjectModel p) {
        JavaSourceProjectModel javaProject = p
        for (def c : javaProject.productionClasses) {
            generateFile(configuration, [project: javaProject, class: c], "source.java", "${javaProject.name}/src/main/java/${c.sourceFileName}", outputDir)
        }
        for (def c : javaProject.testCount) {
            generateFile(configuration, [project: javaProject, class: c], "test.java", "${javaProject.name}/src/test/java/${c.sourceFileName}", outputDir)
        }
    }
}

class GradleNativeBuildTask extends GradleBuildTask {
    @InputFile
    File sourceTemplate

    @InputFile
    File libraryHeaderTemplate

    @InputFile
    File appSourceTemplate

    @InputFile
    File testSourceTemplate

    @InputFile
    File headerTemplate

    @Override
    void registerTemplates(StringTemplateLoader loader) {
        loader.putTemplate("main.c", appSourceTemplate.text)
        loader.putTemplate("source.c", sourceTemplate.text)
        loader.putTemplate("test.c", testSourceTemplate.text)
        loader.putTemplate("source.h", headerTemplate.text)
        loader.putTemplate("library.h", libraryHeaderTemplate.text)
    }

    @Override
    void generateProjectFiles(Configuration configuration, ProjectModel p) {
        CSourceProjectModel cProject = p
        cProject.implSourceNames.each { name ->
            def baseName = name.replace(".c", "")
            generateFile(configuration, [project: cProject, name: baseName], "source.c", "${cProject.name}/src/main/c/${name}", outputDir)
        }
        cProject.implHeaderNames.each { name ->
            def baseName = name.replace(".h", "")
            generateFile(configuration, [project: cProject, name: baseName], "source.h", "${cProject.name}/src/main/headers/${name}", outputDir)
        }
        cProject.testSourceNames.each { name ->
            def baseName = name.replace(".c", "")
            generateFile(configuration, [project: cProject, name: baseName], "test.c", "${cProject.name}/src/test/c/${name}", outputDir)
        }
        if (!cProject.library) {
            generateFile(configuration, [project: cProject, name: name], "main.c", "${cProject.name}/src/main/c/main.c", outputDir)
        } else {
            generateFile(configuration, [project: cProject, name: name], "library.h", "${cProject.name}/src/main/headers/${cProject.publicHeaderName}", outputDir)
            generateFile(configuration, [project: cProject, name: name], "main.c", "${cProject.name}/src/test/c/main.c", outputDir)
        }
    }
}

class MavenCoords {
    String group = "test"
    String name
    String version = "1.0"
}

class ModuleModel extends MavenCoords {
    List<MavenDependency> dependencies = []
}

class MavenDependency extends MavenCoords {
    String scope
}

class MavenRepoTask extends TemplateTask {
    @InputFile File pomTemplate

    @Override
    def generate(Configuration configuration, StringTemplateLoader loader) {
        loader.putTemplate("pom.xml", pomTemplate.text)
        generateTree(configuration, 'test-compile')
        generateTree(configuration, 'test-compile2')
        generateTree(configuration, 'test-runtime')
        generateTree(configuration, 'test-provided')
        generateTree(configuration, 'test-test')
    }

    def generateTree(Configuration configuration, String name) {
        def main = new ModuleModel(name: name)
        main.dependencies << new MavenDependency(name: "${name}-compile")
        main.dependencies << new MavenDependency(name: "${name}-compile2", scope: 'compile')
        main.dependencies << new MavenDependency(name: "${name}-runtime", scope: 'runtime')
        main.dependencies << new MavenDependency(name: "${name}-provided", scope: 'provided')
        main.dependencies << new MavenDependency(name: "${name}-test", scope: 'test')
        generatePom(configuration, main)
        generatePom(configuration, new ModuleModel(name: "${name}-compile"))
        generatePom(configuration, new ModuleModel(name: "${name}-compile2"))
        generatePom(configuration, new ModuleModel(name: "${name}-runtime"))
        generatePom(configuration, new ModuleModel(name: "${name}-provided"))
        generatePom(configuration, new ModuleModel(name: "${name}-test"))
    }

    def generatePom(Configuration configuration, ModuleModel module) {
        def pomPath = "${module.group}/${module.name}/${module.version}/${module.name}-${module.version}.pom"
        def jarPath = "${module.group}/${module.name}/${module.version}/${module.name}-${module.version}.jar"

        generateFile(configuration, [module: module], "pom.xml", pomPath, outputDir)

        def jarFile = new File(outputDir, jarPath)
        jarFile.parentFile.mkdirs()
        jarFile.createNewFile()
    }
}

class MavenBuildTask extends TemplateTask {
    @InputFile File pomTemplate

    @Override
    def generate(Configuration configuration, StringTemplateLoader loader) {
        loader.putTemplate("pom.xml", pomTemplate.text)
        def module = new ModuleModel(name: 'main')
        module.dependencies << new MavenDependency(name: 'test-compile')
        module.dependencies << new MavenDependency(name: 'test-compile2', scope: 'compile')
        module.dependencies << new MavenDependency(name: 'test-runtime', scope: 'runtime')
        module.dependencies << new MavenDependency(name: 'test-provided', scope: 'provided')
        module.dependencies << new MavenDependency(name: 'test-test', scope: 'test')
        generateFile(configuration, [module: module, repo: new Repo(uri: project.file("build/mavenRepo").toURI())], "pom.xml", "pom.xml", outputDir)
    }
}

task mavenRepo(type: MavenRepoTask) {
    outputDir = file("$buildDir/mavenRepo")
    pomTemplate = file("templates/maven/repo/pom.xml.ftl")
}

task mavenBuild(type: MavenBuildTask) {
    dependsOn mavenRepo
    outputDir = file("$buildDir/maven")
    pomTemplate = file("templates/maven/build/pom.xml.ftl")
}

task androidApp(type: GradleJvmBuildTask) {
    dependsOn mavenRepo
    outputDir = file("$buildDir/android")
    settingsTemplate = file("templates/common/settings.gradle.ftl")
    rootProjectTemplate = file("templates/android/build.gradle.ftl")
    projectTemplate = file("templates/android/project/build.gradle.ftl")
    sourceTemplate = file("templates/java/project/library.java.ftl")
    testSourceTemplate = file("templates/java/project/libraryTest.java.ftl")

    build = new BuildModel()
    build.rootProject.name = 'TestApp'
    build.addSubproject(new JavaAppModel(name: 'app'))
    build.addSubproject(new JavaLibraryModel(name: 'lib1'))
    build.addSubproject(new JavaLibraryModel(name: 'lib2'))
}

task javaApp(type: GradleJvmBuildTask) {
    dependsOn mavenRepo
    outputDir = file("$buildDir/java")
    settingsTemplate = file("templates/common/settings.gradle.ftl")
    rootProjectTemplate = file("templates/java/build.gradle.ftl")
    projectTemplate = file("templates/java/project/build.gradle.ftl")
    sourceTemplate = file("templates/java/project/library.java.ftl")
    testSourceTemplate = file("templates/java/project/libraryTest.java.ftl")

    build = new BuildModel()
    build.rootProject.name = 'TestApp'
    build.addSubproject(new JavaAppModel(name: 'app', sourceCount: 2500, testCount: 500))
    (1..49).each { i ->
        build.addSubproject(new JavaLibraryModel(name: "lib$i", sourceCount: 2500, testCount: 500))
    }
}

task nativeApp(type: GradleNativeBuildTask) {
    outputDir = file("$buildDir/native")
    settingsTemplate = file("templates/common/settings.gradle.ftl")
    rootProjectTemplate = file("templates/native/build.gradle.ftl")
    projectTemplate = file("templates/native/project/build.gradle.ftl")
    headerTemplate = file("templates/native/project/library.h.ftl")
    libraryHeaderTemplate = file("templates/native/project/library-public.h.ftl")
    sourceTemplate = file("templates/native/project/library.c.ftl")
    appSourceTemplate = file("templates/native/project/main.c.ftl")
    testSourceTemplate = file("templates/native/project/test.c.ftl")

    build = new CBuildModel(sourceCount: 10, testCount: 5)
    build.rootProject.name = 'TestApp'
    (1..120).each { i ->
        def deps = i > 1 ? (1..i-1).collect { n -> "lib$n" } : []
        build.addLibrary(name: "lib$i", dependsOn: deps)
    }
    def all = (1..120).collect { i -> "lib$i" }
    build.addApp(name: 'app1', dependsOn: all)
    build.addApp(name: 'app2', dependsOn: all)
}
